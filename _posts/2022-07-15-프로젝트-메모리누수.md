이번글에서는 가격알리미 서비스에서 제가 겪은 메모리 누수현상과 그 해결과정을 설명하고자 합니다.  
가격알리미의 서버가 간헐적으로 다운이 됐었고, aws 클라우드 워치로 메모리 현황을 살펴본 결과 메모리 점유율이 가파르게 치솟고 있었습니다.  
<br />

일주일에 한두번씩 서버가 죽곤 했는데, 서버다운으로 인한 부작용을 최소화하기 위해 서버가 죽을때 다시 자동으로 재기동하는 프로세스를 사전에 구비했었지만
서버다운의 빈도가 너무 잦다고 판단해 빠르게 해결해나갔습니다.  

 
<p align="center">
  <img src="/images/memory_leak/new-memory-leak-1.png" alt="book" width="800"/>
</p>
위 그래프는 제가 당시 겪었던 메모리 누수 그래프와 비슷한데요 클라이언트가 요청할 당시 가파르게 상승했다가
요청이 끝나면 참조되고 있는 메모리를 GC가 해결하지 못해 그래프가 수평을 그리고 있다가 또 클라이언트가 요청이 들어오면
다시 상승을 반복합니다.  

결국 메모리 점유율이 80%~90%정도 도달하게 되면 Application이 Out of Memory 현상으로 다운되고 리눅스에 설정해논
재시작 명령어로 다시 켜지는 현상을 반복합니다.  
<br />

12시, 6시 기점으로 서버가 감당할 수 있는 리퀘스트보다도 더 많은 리퀘스트가 발생했습니다(1초당 70회)
저희 서비스는 pass앱 내부에서 이용할 수 있는 부가서비스로,  
당시 코로나 QR체크를 위해 다수의 고객이 식사시간대에 pass앱을 켜면 부가서비스를 이용하지 않는 고객의 요청임에도 불구하고
부하가 발생하면서 나타난 현상이었습니다.  

앱 접속이나, 단순 인증에 관한 요청을 제외한 실제 저희 부가서비스를 이용하는 경우에만 리퀘스트를 발생시키면 되지않을까 라는 생각도 해보았지만  
접속, 단순인증 요청이더라도 항상 연동 api을 사용해야하는 경우가 대부분이라는것을 경험을통해 추정하게 되었습니다.  
<br />
<br />
정확히 어떤 포인트에서 부하가 발생하는지 파악하기 위해 부하테스트를 진행해본결과 
저의 경우에는 모델매퍼가 메모리 점유율 1순위를 차지하고있었습니다.  
따라서 모델매퍼 내부 로직에서 메모리 누수 이슈가 있을것이라 추정해 소스를 분석해보니 매번 새로운 객체를 생성해주면서 발생하는 문제였습니다.
```
public static DevicePrice DevicePriceEntityToDevicePrice(DevicePriceEntity entity){
  return modelMapper.createTypeMap(DevicePriceEntity.class, DevicePrice.class)
    .addMapping(DevicePriceEntity::getDeviceId, DevicePrice::setDeviceId)
    .addMapping(DevicePriceEntity::getHighPrice, DevicePrice::setHighPrice)
    ...
    .map(entity);
}
```
위 소스가 메모리 누수의 원인이 됐던 소스입니다.  
DevicePriceEntityToDevicePrice 메소드를 호출할때마다 modelMppaer에서 제공하는 createTypeMap메소드로 객체가 생성되고  
어떤 이유에서 GC가 메모리를 해결하지 못하는 현상이 있었습니다.  

```
public static DevicePrice DevicePriceEntityToDevicePrice(DevicePriceEntity entity){

  TypeMap<DevicePriceEntity, DevicePrice> typeMap =
  modelMapper.getTypeMap(DevicePriceEntity.class, DevicePrice.class);
  
  if (typeMap == null){
    return modelMapper.createTypeMap(DevicePrice.class, DevicePrice.class)
      .addMapping(DevicePriceEntity::getDeviceId, DevicePrice::setDeviceId)
      .addMapping(DevicePriceEntity::getHighPrice, DevicePrice::setHighPrice)
      ...
      .map(entity);
  }else{
    return typeMap;
  }
}
```
위 그림은 변경 후 소스입니다. Modelmapper에서 제공하는 getTypeMap 메소드를 이용해서 기존에 정의한게 있는지  
확인후에 있으면 그 타입맵을 반환하고 없다면 새로 생성해줘서 싱글톤형태로 사용했습니다.   
<br />
<br />



<p align="center">
  <img src="/images/memory_leak/memory_leak_03.png" alt="book" width="800"/>
</p>
위의 faq내용과 같이 모델매퍼 공식 문서에서는 메모리 누수를 피하기 위해서는 쓰레드세이프한경우에만 사용하고, 재사용하는게 최선이며
만약 모델매퍼 의존성을 주입해서 사용하고 있다면, 싱글톤패턴으로 호출하도록 수정해야 한다고 결론지어졌습니다.  

모델 매퍼 무한 객체생성 문제를 해결하고 난 후 다시 부하 테스트를 해보니 예상대로 메모리 누수 현상이 사라졌습니다.  

 
<p align="center">
  <img src="/images/memory_leak/new-memory-leak-2.png" alt="book" width="800"/>
</p>
cloud watch로 확인한 결과 위 그래프 처럼 메모리 점유율이 위아래로 변동폭은 있으나  
전체적으로 수평을 그리는 모습입니다.   
<br />
<br /><br />
<br />

결론 : 모델매퍼를 싱글톤으로 제대로 사용하자
