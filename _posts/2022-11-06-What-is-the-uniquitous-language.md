# 유비쿼터스 랭귀지란 무엇인가  

에릭 에반스의 Domain driven design 책을 읽다가 유비쿼터스 랭귀지에 대한 내용이 나오는데  

오늘은 이 유비쿼터스 랭귀지에 대한 내용을 포스트 해보려 합니다.



### To remember:  
유비쿼터스 랭귀지는 비즈니스 도메인이라고 인식되는 영역과 콘셉 안에서 제한된 영역 안에서 모델되어야되고  

모호함을 가져서는 안됩니다.

<p align="center">
  <img src="/images/ubiquitous_language/UbiquitousLanguage_1.png" alt="book" width="650"/>
</p>  

유비쿼터스 랭귀지는 에릭에반스가 Domain-Driven Design -- Tackling Complexity in the Heart of Software에서  

팀, 개발자 , 도메인 전문가, 다른 참여자들과 공유할 수 있는 언어를 만들기 위해 사용된 용어입니다.


우리가 소프트웨어가 어떻게 디자인 되었든지 상관없이 소프트웨어는 제한된 컨텍스트 안에서 모델링된 유비쿼터스 랭귀지를 반영해야 합니다.  

깔끔한 유비쿼터스 랭귀지를 만들지 위해서는 우리는 비즈니스에 대해 더 이해해야 합니다.  

### 유비쿼터스 랭귀지의 특징  

- 유비쿼터스 랭귀지는 도메인 모델 안에서 표현되어야된다.
- 유비쿼터스 랭귀지는 프로젝트 팀의 사람들을 하나로 묶는다.
- 유비쿼터스 랭귀지는 도메인 전문가로부터 부정확함과 모순을 제거한다.
- 유비쿼터스 랭귀지는 도메인 전문가로부터 온 비즈니스 랭귀지가 아니다.
- 유비쿼터스 랭귀지는 산업 현장에서 쓰이는 랭귀지가 아니다.
- 유비쿼터스 랭귀지는 시간이 지남에 따라 진화하며 한번의 미팅으로 전부 정의되어지는게 아니다.
- 유비쿼터스 랭귀지의 부분이 아닌 컨셉은 거부되어야된다.

### 흔한 문제

에릭 에반스가 생각하는 우리가 피해야 되는것  

- 공통 언어에 대한 부족 : 
공통 언어에 대한 부족은 통역을 강제하고 그것은 도메인 모델에 좋지 않다 그리고 그런 현상은 올바르지 않은 도메인 모델의 생성을 초래한다  
- 팀 맴버가 공통 언어의 부족이라는 이유로 똑같은 용어를 다른식으로 사용하는것 
- 유비쿼터스 랭귀지가 존재 함에도 유비쿼터스 용어를 사용하지 않고 소통하는것
- 도메인 전문가들은 이해할수 없는 기술팀의 의해 만들어진 도메인 모델을 위한 추상적인 생성
- 도메인 전문가의 참여를 고려하지 않아서 너무 도메인 전문가들에게는 너무 추상적으로 느껴지는 상태 : 
  만들어진 도메인 모델의 유효성을 체크하려면 도메인 전문가들의 참여는 필수적이다.


### 어떻게 유비쿼터스 랭귀지를 발전시킬까?  

우리는 아마도 우리에게 되물을 것입니다.
어떻게 유비쿼터스 발전시킬수 있을까 방법이 무엇일까 무엇이 연관되어있을가 프로세스는 어떻게 될까?  

첫번째 포인트는 공개토론, 기존 도큐먼트, 사전, 기준, 그리고 다른 것들의 대한 분석이 있어야 우리는 더 좋은 언어를 생각해낼수 있다는것입니다.  

### Draw  


우리의 도메인을 규격화 되거나 디자인 되는지 말든지 걱정하지 말고 화이트 보드에 표현해야 합니다.

### Create a glossary  

개발자들은 용어들을 정의와 함께 리스트화 해야됩니다.  

### Use Event storming  

도메인 전문가와 개발자는 이벤트 스토밍을 사용해서 빠르게 비즈니스 프로세스 러닝 싸이클을 달성 할 수 있습니다.  
그것은 유비쿼터스 개발에 도움을 줍니다.  

### Review and update  

애자일 방법으로 생성된 것을 리뷰나 업데이트 할 준비가 되어야 합니다.

####  Vaughn Vernon says:  
코드는 유비쿼터스 랭귀지를 표현하는 꾸준한 방법입니다.
따라서 그리는것 용어를 정리하는것 다른 도큐먼트를 정리하는것이 버려지는것을 경계해야 합니다.
그것은 최신화 하기 어려울것이기 때문입니다.

## 우리의 코드는 유비쿼터스 랭귀지를 표현해야된다  
우리는 e-commerce system을 개발하고 있고 product owner가 다음과 같은 요구사항이 있다고 상상해봅시다

"그 시스템은 소비자의 이메일을 변경해야된다."

요구사항은 간단하지만 어떤에 이것을 우리의 코드 속에 녹여서 표현할 수 있을까요??

여기에 간단한 구현 예제가 있습니다.
``` 
public class People : Entity
{
    public string Name { get; set; }
    public string Email { get; set; }
    ...

    public void Update(string name, string email, ...)
    {
        if(!string.IsNullOrEmpty(name))
        {
            Name = name;
        }

        if(!string.IsNullOrEmpty(email))
        {
            Email = email;
        }

        ...
    }
}
```  
이 코드를 보면 유비쿼터스 랭귀지를 반영했다고 느껴지지 않습니다.  

Value Object, Domain Service, Repositories, Commands, Events 등등 이것들은 유비쿼터스 랭귀지로 표현되어야 합니다.  

다음 예제는 유비쿼터스 랭귀지가 반영된 코드입니다.  

```
public class Client : Entity
{
    public string Name { get; private set; }
    public string Email { get; private set; }
    ...

    public void ChangeEmail(string email)
    {
        Email = email;
    }
}
```  


### 결론
도메인 모델의 유비쿼터스 랭귀지를 토론하고, 찾고, 컨셉화하고, 발전시키고, 말해보자.


