 # 스마트 가격 알리미 프로젝트 설명
 
 프로젝트 기술 스펙
 spring jpa, spring boot, aws, spring batch, spring security, redis, mongdb, mysql

 스마트 가격알리미는 부가서비스입니다.
 간단하게 기능들을 설명하자면 다음과 같습니다.
 
 
**스마트폰 시세 메뉴**  


 내 스마트폰의 중고 시세 최저가 평균가 최고가를 알 수 있고 물론 내 폰이 아니어도 다른 기종도 찾아볼 수 있습니다.  
 공시지원금도 알 수 있습니다.
 
**스마트 쇼핑 메뉴**  

 
 에누리에서 제공받은 데이터로 전자기기 종류의 매일 갱신되는 최저가 최고가 정보를 알 수 있습니다.  
 만약 내가 원하는 가격을 입력할 경우 매일 가격이 변동되다가 원하는 가격 이하로 떨어진다면  
 앱 푸시로 알려줍니다.  
 매월 택배 포인트 500point를 제공 받을수도 있고  
 물품 구매 후 파손등으로 인한 (재)구매 비용을 최대 100만원 보상해줍니다.


 일단 사용자 관점에서 어떤어떤 기능이 있는지 유스 케이스로 작성해봤습니다.
<p align="center">
  <img src="/images/smart_price_notice/AllUseCase.png" alt="book" width="1200"/>
</p>  



**무료회원**
 - 스마트폰 시세확인
 - 최저가 관심상품 한개 등록하기
 
**유료회원**
 - 최저가 관심상품 여러개 등록하기
 - 스마트폰 시세확인
 - 쇼핑혜택
 - 택배 포인트 신청하기

다음은 실제 서비스 되고 있는 페이지들입니다.

<p align="center">
  <img src="/images/smart_price_notice/smart_all.jpg" alt="book" width="250"/>
 <img src="/images/smart_price_notice/smart_gongsi.jpg" alt="book" width="250"/>
 <img src="/images/smart_price_notice/smart_low_list.jpg" alt="book" width="250"/>
 <img src="/images/smart_price_notice/smart_low_price.jpg" alt="book" width="250"/>
 <img src="/images/smart_price_notice/smart_low_price_main.jpg" alt="book" width="250"/>
 <img src="/images/smart_price_notice/smart_my_phone.jpg" alt="book" width="250"/>
</p>  


단순 CRUD페이지를 제외하고 설명하고자 합니다.

첫번째로 설명할 기능은 에누리에게 5기가 xml 파일을 오전 06:00 받아서 (에누리가 당일 가지고 있는 Stuff 전체 데이터)  
약 40분동안 Mongo db에 스프링 배치로 적제하고 그 데이터를 이용해서 스마트 쇼핑 최저가 가격조회 목록들을 보여줍니다.  
<p align="center">
  <img src="/images/smart_price_notice/smart_low_list.jpg" alt="book" width="250"/>
</p>  

Mongo db로 정한 이유는 다음과 같습니다.  
  - 많은 데이터(에누리의 있는 모든 Stuff들이 저장되어야 합니다.)
  - 빠른 응답시간
  - [Eventual Consistency](https://www.scylladb.com/glossary/eventual-consistency/)


적용하다보니 검색에 어려움이 있었습니다.
워낙 데이터가 많다보니 (2000만건 이상) Like 검색으로는 한계가 있었습니다.  
하지만 ELK를 적용하기에는 시간이 부족했고 경험도 부족했습니다.  
그래서 Mongo DB에서 지원하는 [Text Search](https://www.mongodb.com/docs/manual/text-search/) 기술을 사용했습니다.  
속도는 만족할 만큼 나왔지만 키워드에 대한 랭크 지정 등등 나오는 리스트가 에누리 검색 리스트와 너무 동떨어진점이 많았지만  
기술도 인력도 부족해서 그정도로 만족하고 넘어갔습니다.
혹시 에누리쪽에 검색 후 나오는 리스트 Api가 있는지 문의하였으나 그런 Api는 없었습니다.  

<br />
<br />
<br />
<br />
  
  
### LGT 회원 정보 연동 API  
두번째로 설명할 기능은 회원 가입, 해지, 로그인 Api 연동입니다.  
초기에 클라이언트쪽에서 요구한 TPS는 100.0/sec 이었습니다.
1000 ms(평균)

엄청난 요구는 아니었지만 일단 Jmeter를 이용해서 부하 테스트를 시행했는데
절반도 못미치는 성능이 나왔고 그 이후에는 Transaction time out이 떴습니다.

원인은 JPA에서 제공하는 ID 생성 전략중 제가 고른 TABLE 전략때문이었습니다.  
간단하게 ID 생성 전략을 설명하자면  
JPA에서 제공하는 아이디 생성 전략은 4가지가 있습니다.
 - AUTO
 - IDENTITY
 - SEQUENCE
 - TABLE

### AUTO
AUTO 전략은 자동으로 특정한 데이터베이스에 맞게 적당한 전략을 취합니다.
AUTO 전략은 GenerationType의 디폴트 값이고 단순히 @GeneratedValue 어노테이션만 쓴다면 이 전략이 적용됩니다.



### IDENTITY
IDENTITY 전략은 데이터베이스의 Identity컬럼에서 값을 가져옵니다.   
이 말은 auth-incremented이라는 뜻입니다.
사용법은 아래와 같습니다.
```
@Entity
public class Student {

    @Id
    @GeneratedValue (strategy = GenerationType.IDENTITY)
    private long studentId;

    // ...
}
```

### SEQUENCE  
시퀀스 기반 아이디를 사용하기 위해 Hibernate는 SquenStyleGenerator 클래스를 제공하고
이 제너레이터는 데이터베이스가 시퀀스를 지원한다면 시퀀스를 사용하고 만약 지원하지 않는다면 테이블 제너레이션을 사용합니다.
시퀀스 이름을 커스텀하기위해 @GenericGenerator 어노테이션으로 SequenceStyleGenerator 전략을 사용할 수 있습니다.  
사용법은 다음과 같습니다.

```
@Entity
public class User {
    @Id
    @GeneratedValue(generator = "sequence-generator")
    @GenericGenerator(
      name = "sequence-generator",
      strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
      parameters = {
        @Parameter(name = "sequence_name", value = "user_sequence"),
        @Parameter(name = "initial_value", value = "4"),
        @Parameter(name = "increment_size", value = "1")
        }
    )
    private long userId;
    
    // ...
}
``` 
위와같이 초기 시작값 4로 설정할 수 있습니다.  
이 전략은 하이버네이트 도큐먼테이션에서 추천하는 방법입니다.  



### TABLE
TABLE 전략은 절대 쓰지 말아야할 전략입니다.  
퍼포먼스의 부정적인 영향이 있습니다.  
저도 이 전략을 썼다가 트랜잭션 타임아웃이 났습니다.  
사용법은 아래와 같습니다.
```
@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, 
      generator = "table-generator")
    @TableGenerator(name = "table-generator", 
      table = "dep_ids", 
      pkColumnName = "seq_id", 
      valueColumnName = "seq_value")
    private long depId;

    // ...
}
```

## @GeneratedValue not used
만약 @GeneratedValue 어노테이션을 안쓴다면 직접 PK를 지정해야됩니다.  
예를들면 간단하게 System.nanoTime()을 지정할수도 있습니다.

```
@Entity
public class Student {
  @Id
  private long myId = System.nanoTime();

  public long getMyId() {
      return myId;
  }

  public void setMyId(long myId) {
      this.myId = myId;
  }
}
```  

위의 전략중 아이디 생성 전략을 TABLE에서 IDENTITY로 바꾸니 거짓말처럼 성능이 개선됐습니다.  
저는 개발하는데 시작이 부족했고 급하게 성능이슈를 처리하기 위해서 IDENTITY로 해결했지만 사실 가장 좋은 전략은 SEQUENCE입니다.  
기회가 되면 SEQUENCE의 장점을 포스트해보려 합니다.  


좀더 저희 프로젝트를 설명하고 싶지만 이만 줄이려고 합니다.  



이 프로젝트에서 배운점  
NoSql의 장점, JPA, JPA ID생성 전략 등등...  



출처  
[https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-sequence](https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-sequence)  
[https://vladmihalcea.com/jpa-entity-identifier-sequence/](https://vladmihalcea.com/jpa-entity-identifier-sequence/)  
[https://www.baeldung.com/hibernate-identifiers](https://www.baeldung.com/hibernate-identifiers)  
[자바 ORM 표준 JPA 프로그래밍 - 김영한 저](https://www.coupang.com/vp/products/20488571?itemId=80660090&vendorItemId=3314421212&src=1042503&spec=10304982&addtag=400&ctag=20488571&lptag=10304982I80660090&itime=20220828165641&pageType=PRODUCT&pageValue=20488571&wPcid=16449716697050559924219&wRef=&wTime=20220828165641&redirect=landing&gclid=CjwKCAjwpKyYBhB7EiwAU2Hn2bYUcWAIwGmMVb5xRlL10rGndXeD1WNyKnqurgrQUt8dc-hR7P9TGhoCFtAQAvD_BwE&campaignid=12207438463&adgroupid=115720946583&isAddedCart=)

